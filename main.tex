\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage[english]{babel}
\usepackage{amsthm}
\usepackage{cite}
\usepackage{amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage[fleqn]{amsmath}
\usepackage[a4paper, total={184mm,239mm}]{geometry}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\theoremstyle{definition}
\newtheorem{definition}{Definition}
\usepackage{listings}
\usepackage{stfloats}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{xcolor}
% \usepackage[fleqn]{amsmath}
\usepackage{lstautogobble}  % Fix relative indenting
\usepackage{color}          % Code coloring
\usepackage{zi4}            % Nice font

\definecolor{bluekeywords}{rgb}{0.13, 0.13, 1}
\definecolor{graycomments}{rgb}{0.5, 0.5, 0.5}
\definecolor{redstrings}{rgb}{0.9, 0, 0}
\definecolor{graynumbers}{rgb}{0.5, 0.5, 0.5}

\lstset{
    autogobble,
    columns=fullflexible,
    showspaces=false,
    showtabs=false,
    breaklines=true,
    showstringspaces=false,
    breakatwhitespace=true,
    escapeinside={(*@}{@*)},
    commentstyle=\color{graycomments},
    keywordstyle=\color{bluekeywords},
    stringstyle=\color{redstrings},
    numberstyle=\color{graynumbers},
    basicstyle=\ttfamily,
    xleftmargin=18pt,
    xrightmargin=2pt,
    tabsize=4,
    captionpos=b
}
\lstset
{ %Formatting for code in appendix
    language=Matlab,
    % basicstyle=\footnotesize,
    numbers=left,
    stepnumber=1,
    showstringspaces=false,
    tabsize=1,
    breaklines=true,
    breakatwhitespace=false,
}
\lstset{
numbers=left, 
numberstyle=\small, 
numbersep=8pt, 
frame = single, 
language=Pascal, 
framexleftmargin=15pt}

\pagestyle{empty}
\begin{document}

\title{RVFC: RISC-V Formal in Chisel
% {\footnotesize \textsuperscript{*}Note: Sub-titles are not captured in Xplore and
% should not be used}
% \thanks{Identify applicable funding agency here. If none, delete this.}
}

% \author{\IEEEauthorblockN{1\textsuperscript{st} Given Name Surname}
% \IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
% \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID}
% \and
% \IEEEauthorblockN{2\textsuperscript{nd} Given Name Surname}
% \IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
% \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID}
% \and
% \IEEEauthorblockN{3\textsuperscript{rd} Given Name Surname}
% \IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
% \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID}
% \and
% \IEEEauthorblockN{4\textsuperscript{th} Given Name Surname}
% \IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
% \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID}
% \and
% \IEEEauthorblockN{5\textsuperscript{th} Given Name Surname}
% \IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
% \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID}
% \and
% \IEEEauthorblockN{6\textsuperscript{th} Given Name Surname}
% \IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
% \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID}
% }

\maketitle

\begin{abstract}
    DUMMY ABSTRACT.
    Modern digital hardware is becoming ever more complex. And agile development, an efficient idea in software development, has been introduced into hardware. Furthermore, as a new hardware construction language, Chisel helps to raise the level of hardware design abstraction with the support of object-oriented and functional programming. Chisel plays a crucial role in future hardware design and open-source hardware development. However, the formal verification for Chisel is still limited. In this paper, we propose ChiselFV, a formal verification framework that has supported detailed formal hardware property descriptions and integrated mature formal hardware verification flows based on SymbiYosys. It builds on top of Chisel and uses Scala to drive the verification process. Thus the framework can be seen as an extension of Chisel. ChiselFV makes it easy to verify hardware designs formally when implementing them in Chisel.
\end{abstract}

\begin{IEEEkeywords}
RISC-V, Formal Verification, Hardware verification, Chisel
\end{IEEEkeywords}

\section{Introduction}
The dominant traditional hardware-description languages (HDLs), Verilog and VHDL, were originally developed as hardware simulation languages, and were only later adopted as a basis for hardware synthesis. 
These languages also lack the powerful abstraction facilities that are common in modern software languages, which leads to low designer productivity by making it difficult to reuse components.
% 因此 Chisel 被推出。
Therefore, Chisel was proposed.
It is intended to be a simple platform that provides modern programming language features for accurately specifying low-level hardware blocks, but which can be readily extended to capture many useful high-level hardware design patterns \cite{bachrach2012chisel}.

% Chisel
Chisel (Constructing Hardware in a Scala-Embedded Language) is an open-source hardware construction language developed by UC Berkeley. It is developed as a domain-specific extension to the Scala programming language. And because Chisel is embedded in Scala, hardware developers can tap into Scala’s modern programming language features—such as object-oriented programming, functional programming, parameterized types, abstract data types, operator overloading, and type inference—to improve designer productivity by raising the abstraction level and increasing code reuse \cite{lee2016agile}.

% RISC-V
% Chisel 是为了敏捷开发 RISC-V 处理器而开发的，其生态因为其语言特性和 RISC-V 的流行而逐渐壮大。
Chisel was developed for agile development of RISC-V processors, and its ecosystem has grown due to its language features and the popularity of RISC-V.
RISC-V is an ISA developed at UC Berkeley and designed from the ground up to be clean, microarchitecture-agnostic and highly extensible. Most importantly, RISC-V is free and open, which allows it to be used in both commercial and open-source settings \cite{asanovic2014instruction}.
% UC Berkeley 也推出了两款具有代表性的基于 Chisel 的 RISC-V 芯片生成器。
UC Berkeley has also released two representative RISC-V chip generators based on Chisel: Rocket Chip \cite{asanovic2016rocket} and BOOM \cite{celio2017boomv2}.
% 这其中后者是一个乱序核。
The latter is an out-of-order core.
% Chisel 由于其高级语言的特性，提供了更强的抽象能力，从而提供了便利的库开发能力。
Chisel, due to its high-level language features, provides more powerful abstraction capabilities, thus providing convenient library development capabilities. 
% 前文中提到的 Rocket chip 实际上是一个 Chip 生成器，它由一系列的参数化的构建芯片库构成。
The Rocket Chip mentioned above is actually a chip generator, which consists of a collection of parameterized chip-building libraries that we can use to generate different SoC variants \cite{asanovic2016rocket}.
% 基于它的 Raven 系列芯片已经可以进行流片了。
The Raven family of chips based on it have already been taped out \cite{lee2015raven}.

% 验证的重要性，但是目前的处理器验证主要是在 SystemVerilog 层次。
% 在硬件开发流程中，由于其错误的代价十分高昂，设计的正确性验证是至关重要的。
In the hardware development process, due to the high cost of errors, the correctness verification of the design is crucial.
% 然而当前的处理器验证工作主要是在 SystemVerilog 层次。
However, current processor verification efforts are mainly at the SystemVerilog level.
% 对于 RISC-V 指令集处理器验证的代表性工作为 RISC-V Formal。
The representative work for RISC-V instruction set processor verification is RISC-V Formal \cite{riscv-formal}.
% RISC-V Formal 实现了什么，但是，不足：1. 层次 2. 框架结构
% RISC-V Formal 包含了一个处理器独立的 RISC-V ISA 形式化描述一组验证 testbench。
RISC-V Formal consists of a processor-independent formal description of the RISC-V ISA and a set of formal testbenches for each processor supported by the framework.
% 实现了 RISC-V Formal 中定义的 RVFI(RISC-V Formal Interface) 接口的 RISC-V core 都可以使用它进行形式化验证。
Any RISC-V core that implements the RVFI (RISC-V Formal Interface) defined in RISC-V Formal can use it for formal verification.
% 然而，RISC-V Formal 验证框架是在 SystemVerilog 层次的。
However, the RISC-V Formal verification framework is at the SystemVerilog level.
% 基于之前对于 Chisel 的说明和一些比较的工作，相比底层 HDL 语言，例如 SystemVerilog，Chisel 在设计和验证上都更具有生产力。
Based on the previous description of Chisel and some comparative work, Chisel is more productive in design and verification than low-level HDL languages, such as SystemVerilog \cite{im2021comparative}.
% 同时， Chisel 生成的 SystemVerilog 代码的可读性和可修改性较差，因此无法直接使用 RISC-V Formal 对 Chisel 实现的 Core 进行形式化验证。
At the same time, the readability and modifiability of the SystemVerilog code generated by Chisel is poor, it is not possible to directly use RISC-V Formal to verify the core implemented by Chisel.
% 另一方面，RISC-V Formal 的验证后端与框架是紧密耦合的，目前只支持调用 BMC 算法。
On the other hand, the verification backend of RISC-V Formal is tightly coupled with the framework, and currently only supports calling the BMC algorithm.

% 我们的贡献
% 基于上述，我们提出 RVFC 框架，受启发于 RISC-V Fomal 框架，并在 Chisel 层次进行实践。
Base on the above, we propose the RVFC (RISC-V Formal in Chisel) framework, inspired by the RISC-V Formal framework, and try to practice it at the Chisel level. 
% ChiselFV
% RVFC 框架基于我们之前的工作 ChiselFV。
The RVFC framework is based on our previous work ChiselFV \cite{ChiselFV}.
% ChiselFV 提供了在 Chisel 层次形式化定义性质，并可以进行一键式调用验证的能力。
ChiselFV provides the ability to formally define properties at the Chisel level and allows for one-click call verification.
% RVFC 相关的代码和 case 都可以在 GitHub 仓库中找到。
The related code and case of RVFC can be found in the GitHub repository \cite{riscvFvChisel}.
The main contributions of this work are as follows:

\begin{itemize}
    \item \textbf{RVFC framework.} 
    We propose the RVFC framework, which is a formal verification framework for RISC-V cores implemented in Chisel. The framework is inspired by the RISC-V Formal framework and is implemented at the Chisel level.
    % 借助 Chisel 中高级语言的特性，RVFC 框架实现了模块化和更好的扩展性。
    And the RVFC framework enables modularity and better extensibility thanks to the high-level language features in Chisel.
    % 验证流程
    \item \textbf{Verification flow.}
    % 我们使用 Chisel 按照教科书中使用 SystemVerilog 实现的一个五级流水案例进行了重新实现，并将其作为 Study case，实践 RVFC 验证框架下对 RISC-V 处理器的验证流程。
    We reimplemented a five-stage pipeline example using Chisel as described in the textbook \cite{patterson2017computer} using SystemVerilog and used it as a study case to practice the verification flow of RVFC verification framework for RISC-V processors.
\end{itemize}

% 文章组织
This paper is organized as follows. Section II introduces the RISC-V Formal framework. Section III details the design and workflow of the RVFC framework. 
% 一个在 Chisel 层次实现的五级流水设计和验证过程在 section IV 中以一个 study case 展示。
A five-stage pipeline design and verification process is presented in section IV as a study case.
Section V concludes.

\section{RISC-V Formal}

RISC-V Formal is a formal verification IP for RISC-V processors.
It is ongoing development and currently supports RV32/64IMC instruction set \cite{riscvf}.
RISC-V Formal consists of a processor-independent formal description of the RISC-V ISA and a set of formal testbenches for each processor supported by the framework.
% 该框架的验证对象在 Verilog/SystemVerilog 层次实现的 RISC-V 处理器，同时要求其实现了 RVFI 接口。
The framework verifies RISC-V processors implemented at the Verilog/SystemVerilog level and requires that they implement the RVFI interface.
% 它使用了 SVA(SystemVerilog Assertions) 在 SystemVerilog 上来定义形式化性质描述。
It uses SVA (SystemVerilog Assertions) \cite{vijayaraghavan2005practical} to define formal property descriptions on SystemVerilog.
% 验证后端则是将 SystemVerilog 和 SVA 代码直接交给 SymbiYosys 工具进行 BMC 检查。
The verification backend is a direct handoff of the SystemVerilog and SVA code to the SymbiYosys \cite{SymbiYosys} tool for BMC checking.

\begin{figure}[!htbp]
    \begin{center}
    \includegraphics[width=1\linewidth]{pics/riscvformal.pdf}
    \caption{RISC-V Formal Framework Design}
    \label{fig: riscvformal}
    \end{center}
\end{figure}
% 图 1 是 RISC-V Formal 的框架设计。
Figure 1 shows the framework design of the RISC-V Formal.
% 首先，在对处理器正确性对验证过程中，内存和外部的 IO 会被抽象掉，连接核心的实现。
First of all, in the process of verifying the correctness of the processor, the memory and external IO will be abstracted and connected to the RISC-V core.
% 两者都作为 rvfi_wrapper 模块的组成。
Both are used as components of the \verb|rvfi_wrapper| module.
% 在核心中，需要实现 RVFI 接口，输出在指令执行过程中的一系列状态信息。
In the core, the RVFI interface needs to be implemented to output a series of state information during the instruction execution process.

\begin{lstlisting}[language=verilog, caption={RVFI Definition (partial)}, label=rvfi]
output [NRET        - 1 : 0] rvfi_valid,
output [NRET * ILEN - 1 : 0] rvfi_insn,
output [NRET *    5 - 1 : 0] rvfi_rs1_addr,
output [NRET * XLEN - 1 : 0] rvfi_rs1_rdata,
output [NRET * XLEN - 1 : 0] rvfi_pc_rdata,
output [NRET * XLEN - 1 : 0] rvfi_pc_wdata,
output [NRET * XLEN   - 1 : 0] rvfi_mem_addr,
output [NRET * XLEN   - 1 : 0] rvfi_mem_rdata,
output [NRET * XLEN   - 1 : 0] rvfi_mem_wdata
\end{lstlisting}

% 可以从上面的 Listing 1 中看到，RVFI 接口要求核心输出指令执行过程中指令编码的内容，指令的源操作数地址和内容，指令执行前后的 PC 值，以及内存访问的地址和内容等。
As shown in Listing \ref{rvfi}, the RVFI interface requires the core to output the contents of the instruction encoding, the source operand addresses and contents, the PC values before and after the instruction execution, and the addresses and contents of the memory access, etc.

% 之后，RVFI 接口作为 rvfi_check 模块的输入。
Then, the RVFI interface is used as the input of the \verb|rvfi_check| module.
% 在 RISC-V Formal 中，实际上包含了有几百个不同的 rvfi_check 模块。
There are actually a few hundred different \verb|rvfi_check| modules in RISC-V Formal.
% 这些多个小的 checker 模块分别对核心中不同方面的正确性进行验证。
These small checker modules verify the correctness of different aspects of the core separately.
% 例如有对 RISC-V 指令集中各个具体指令的执行正确性进行验证的 checkers，有对指令执行前后 PC 寄存器更新是否正确进行检查的 checker，有对通用寄存器值变化进行检查的，等等。
For example, there are checkers that verify the correctness of the execution of specific instructions in the RISC-V instruction set, checkers that check whether the PC register is updated correctly before and after the instruction execution, and checkers that check the change of the general register value, etc.
% 全部的检查内容可以查看项目文档或者相关代码。
All the check contents can be found in the project documentation or the related code \cite{riscv-formal}.

% 在一个具体的 checker 模块中，会包含一个实例化的对应的 spec 模块。在这个 spec 模块中，会依据 RISC-V 官方给出的规范内容来实现对应这一小块的规范内容。
Within a specific checker module, a corresponding spec module is instantiated. In this spec module, the corresponding small piece of specification is implemented according to the official RISC-V specification \cite{waterman2014risc}.
% 例如对于 |add| 指令验证的 checker 模块中，会实例化一个对应的 |insn_spec| 模块。在该模块中，会依据官方规范来定义对于加法指令，会对寄存器等状态变量产生怎样的影响。
For example, in the checker module of the \verb|add| instruction verification, a corresponding \verb|insn_spec| module is instantiated.
In this module, the impact on the registers and other state variables will be defined according to the official specification.
% |insn_spec| 模块会输出指令执行后各个状态变量的变化情况，然后在 checker 模块中，会使用 SVA 语法来描述 spec 输出结果和实际核心的执行情况是一致的断言。
The \verb|insn_spec| module outputs the changes in the state variables after the instruction execution, and then in the checker module, the SVA is used to describe the assertions that the spec output is consistent with the actual core execution.

% 最后，RISC-V Formal 会将这些包含 SVA 的 SystemVerilog 模块交给 SymbiYosys 工具来进行 BMC 检查。
Finally, RISC-V Formal hands over these SystemVerilog modules containing SVA to the SymbiYosys tool for BMC ( Bounded Model Checking) \cite{biere2009bounded}.
% 这里使用自动生成的 sby 文件来驱动 SymbiYosys。
Here, the automatically generated sby file is used to drive SymbiYosys.
% SymbiYosys 会给出性质验证的结果。由于只使用了 BMC 检查，因此只能给出在电路的若干步内，性质是否成立的结论。
SymbiYosys will give the results of the property verification. Since only BMC checking is used, only a conclusion can be given as to whether the property holds within a number of steps of the circuit.

% 基于 RISC-V Formal 的验证方法在业界得到了广泛的应用。
The RISC-V Formal-based verification approach is widely used in the industry. 
% Standard Semiconductor 的 Lion is a formally verified, 5-stage pipeline RISC-V core.
Standard Semiconductor's Lion is a formally verified, 5-stage pipeline RISC-V core.
% 它实现了 RVFI 接口并使用 RISC-V Formal 来进行形式化验证。
It implements the RVFI interface and uses RISC-V Formal for formal verification \cite{lion}.
% lowRISC 的 Ibex is a production-quality open source 32-bit RISC-V CPU core written in SystemVerilog. 它同样使用该框架进行形式化验证。
LowRISC's Ibex is a production-quality open source 32-bit RISC-V CPU core written in SystemVerilog. And it also uses this framework for formal verification \cite{ibex}.
WARP-V is a CPU generator written using Transaction-Level Verilog (TL-Verilog) that implements RISC-V ISA and has been formally verified using riscv-formal \cite{hoover2018formally}.

% 在 RISC-V Formal 中，由于底层使用 SVA 来定义性质，因此整个框架只适用于 SystemVerilog 实现的 RISC-V 处理器。
In RISC-V Formal, the entire framework is only applicable to SystemVerilog implementations of RISC-V processors because the underlying SVA is used to define the properties.
% 尽管，使用 Chisel 来设计和验证 RISC-V 处理器是更有生产力的，是大势所趋。
Although, using Chisel for designing and verifying RISC-V processors is more productive and is the general trend.
% 另一方面，RISC-V Formal 专注于进行 BMC，并且由于耦合强很难扩展到其他验证算法，或者是更换后端引擎。
On the other hand, RISC-V Formal is focused on BMC and is hard to extend to other verification algorithms or to replace the backend engine due to strong coupling.

\section{RISC-V Formal in Chisel}

% RVFC 是在 Chisel 层次对 RISC-V 处理器进行形式化验证的框架，其验证思路受启发于 RISC-V Formal 框架。
RVFC is a formal verification framework for RISC-V processors at the Chisel level, and its verification idea is inspired by the RISC-V Formal framework.
% 与 RISC-V Formal 不同，在 RVFC 中，对于形式化性质的定义和验证依赖于 ChiselFV。
Unlike RISC-V Formal, in RVFC, the definition and verification of formal properties depend on ChiselFV.
% ChiselFV 采用与 Chisel 相同的高级语言 Scala 语言实现，借助现代软件编程语言的高级特性，ChiselFV 具有很强的模块化和可扩展性。
ChiselFV is implemented in the Scala language, which is the same as Chisel. With the help of the advanced features of modern software programming languages, ChiselFV has strong modularity and extensibility.
% ChiselFV 目前支持直接调用 BMC, K-Induction, PDR 三种主流模型检测算法，同时其后端引擎易于插拔更换。
ChiselFV currently supports direct invocation of three mainstream model detection algorithms, BMC, K-Induction, and PDR. At the same time, its backend engine is easy to plug and replace.

% 本章节将通过两部分来详细说明 RVFC 框架，分别是 RVFC 的框架结构和验证流程。
This section details the RVFC framework in two parts, the framework structure and the verification workflow.

\subsection{Framework Structure}
% RVFC 的框架结构与 RISC-V Formal 类似，都需要 chip 实现 RVFI 接口，并将指令执行过程中的相关信息进行输出，最终与按照规范会达到的结果进行一致性断言。
The RVFC framework structure is similar to RISC-V Formal in that it requires the chip to implement the RVFI interface and output information about the instruction execution process, and finally assert consistency with the results that would be achieved according to the specification.

\begin{figure}[!htbp]
    \begin{center}
    \includegraphics[width=1\linewidth]{pics/rvfc.pdf}
    \caption{RVFC Framework Structure}
    \label{fig: rvfc structure}
    \end{center}
\end{figure}

% 如图 2 所示，RVFC 验证框架中主要有三个主体，分别为: 使用 Chisel 实现的 RISC-V 处理器 Chip 模块即验证的对象，制定具体验证内容的 Spec 模块们和驱动验证过程的 Checker 模块。
As shown in Figure \ref{fig: rvfc structure}, there are three main bodies in the RVFC framework, namely: the RISC-V processor Chip module implemented by Chisel, which is the verification object, the Spec modules, which specify the verification content, and the Checker modules that drive the verification process.

\begin{lstlisting}[language=scala, caption={RVFI Definition in RVFC}, label=rvfic]
class RVFI_IO extends Bundle {
    val valid     = Output(Bool())
    val insn      = Output(UInt(32.W))
    val pc_rdata  = Output(UInt(64.W))
    val pc_wdata  = Output(UInt(64.W))
    val rs1_addr  = Output(UInt(5.W))
    val rs2_addr  = Output(UInt(5.W))
    val rs1_rdata = Output(UInt(64.W))
    val rs2_rdata = Output(UInt(64.W))
    val rd_addr   = Output(UInt(5.W))
    val rd_wdata  = Output(UInt(64.W))
    val mem_addr  = Output(UInt(32.W))
    val mem_rdata = Output(UInt(64.W))
    val mem_wdata = Output(UInt(64.W))
    val regs      = Vec(32, Output(UInt(64.W)))
}
\end{lstlisting}

% 与 RISC-V Formal 相同的，RVFC 中的 Chip 模块需要实现 RVFI 接口，将指令执行过程中的相关信息输出。
As in RISC-V Formal, the Chip module in RVFC needs to implement the RVFI interface and output information about the instruction execution process.
% 借助 Scala 语言更强的抽象能力，RVFI 接口被定义成一个 Bundle 的子类，从而更容易维护和扩展。
With the Scala language's greater abstraction capabilities, the \verb|RVFI_IO| is defined as a subclass of \verb|Bundle|, making it easier to maintain and extend.
% 比 RISC-V Formal 更多的是，RVFC 中将所有通用寄存器的状态作为 RVFI 的一部分进行输出，从而更好的检查指令执行的正确性。
In addition to RISC-V Formal, RVFC outputs the state of all general-purpose registers as part of RVFI, which is better for checking the correctness of instruction execution.

% |RVFI_IO| 作为 Chip 模块的输出，同时作为 Spec 模块们和 Checker 模块的输入。
The \verb|RVFI_IO| is the output of the Chip module and is also the input of the Spec modules and the Checker module.
% 同时在 RVFC 中，对于从 Chip 中引出的 RVFI 有时机上的要求。
In RVFC, there are also temporal requirements for RVFI from the Chip.
% 就是要求 RVFI 输出的时刻必须是在该指令提交前，而且在逻辑顺序上在该条指令之前的所有指令指令已经完成提交的之后。
That is, the RVFI output must be before the instruction is committed, and in the logical order, after all the instructions before the instruction have been committed.
% 换句话说，RVFI 需要输出逻辑上当前指令执行之前的状态信息，和该指令准备提交的信息。
In other words, RVFI needs to output the state information before the current instruction is executed, and the information that the instruction is ready to commit.
% 这也增加了该框架的可适用性，因为大多数流水线设计，即使是乱序执行，但是指令的提交仍然是按照指令原本的顺序的。
This also increases the applicability of the framework, because most pipeline designs, even if they are out-of-order, still commit instructions in the original order of the instructions.
% 如何在 Chip 中正确地进行 RVFI 的连接是整个验证工作中最困难的，这将在下一章节的研究案例中有所展示。
How to correctly connect RVFI in the Chip is the most difficult part of the verification work, which will be shown in the study case in the next section.

\begin{lstlisting}[language=scala, caption={SpecOut Definition in RVFC}, label=specout]
class SpecOut extends Bundle {
    val valid     = Output(Bool())
    val rs1_addr  = Output(UInt(5.W))
    val rs2_addr  = Output(UInt(5.W))
    val rs1_rdata = Output(UInt(64.W))
    val rs2_rdata = Output(UInt(64.W))
    val rd_addr   = Output(UInt(5.W))
    val rd_wdata  = Output(UInt(64.W))
    val pc_wdata  = Output(UInt(64.W))
    val mem_addr  = Output(UInt(32.W))
    val mem_wdata = Output(UInt(64.W))
}
\end{lstlisting}

% Spec 模块将 RVFI 作为输入，并输出 SpecOut。
The Spec module takes RVFI as input and outputs SpecOut.
% SpecOut 的定义如 Listing 3 所示。
The definition of \verb|SpecOut| is shown in Listing \ref{specout}.
% 其中的 |valid| 信号输出根据当前的 RVFI 输入，是否符合该验证项目的前提。
The \verb|valid| signal output is based on the current RVFI input, whether it meets the premise of the verification item.
% 例如，在对于指令 |add| 的功能性验证 Spec 模块中，只有当输入的指令格式为 |add|，而且流水线没有发生停滞或者中断时，该 |valid| 信号才会输出为 true。
For example, in the functional verification Spec module for the instruction \verb|add|, the \verb|valid| signal will only output \verb|true| when the instruction format is \verb|add| and the pipeline does not stall or interrupt.
% |SpecOut| 中其他的信号则是根据 RVFI 输入信息和需要验证的内容，使用组合电路，计算得到的规范下的正确的指令提交内容。
The other signals in \verb|SpecOut| are the correct instruction commit content under the specification, calculated by a combinational circuit based on the RVFI input information and the content to be verified.
% 例如对于 |add| 指令的验证，则是会输出根据指令解析得到的原操作数和目标操作数地址、按照地址从寄存器中取出的原操作数、计算得到的目标操作数等。
For example, for the \verb|add| instruction, the information about the source operands and target operands addresses, the source operands fetched from the registers according to the addresses, the target operands calculated and so on are output.

% 最后在 Checker 模块中，主要是对性质的定义和验证过程的驱动。
Finally, in the Checker module, it is mainly the definition of the properties and the driving of the verification process.
% 这里会对于 Chip 输出的 RVFI 和 Spec 模块们输出的 SpecOut 进行一致性的断言。
Consistency is asserted here between the RVFI output from Chip and the SpecOut output from the Spec modules.
% 在 Checker 模块中，可以对需要验证的性质内容，即对应的 Spec 模块们进行配置。
In the Checker module, the properties to be verified, that is, the corresponding Spec modules, can be configured.
% 用户可以增加或者减少此次需要验证的内容，也可以自定义编写 Spec 模块来进行验证。
Users can add or subtract content that needs to be validated this time, or write custom Spec modules to do so.
% 最后，用户可以配置选择调用 ChiselFV 的验证算法，目前提供了 BMC, K-induction, 和 PDR 算法。
Finally, users can configure the verification algorithm of ChiselFV to be called, and the BMC, K-induction, and PDR algorithms are currently provided.

\subsection{Verification Workflow}

\section{Case Study}

\section{Conclusion and Future Work}

\bibliographystyle{IEEEtran}
\bibliography{./ref.bib}

\end{document}
